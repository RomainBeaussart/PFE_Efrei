// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateDisplay {
  count: Int!
}

type AggregateManga {
  count: Int!
}

type AggregateProgression {
  count: Int!
}

type AggregateSeason {
  count: Int!
}

type AggregateSerie {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVideo {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Display {
  id: ID!
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

type DisplayConnection {
  pageInfo: PageInfo!
  edges: [DisplayEdge]!
  aggregate: AggregateDisplay!
}

input DisplayCreateInput {
  id: ID
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayCreateManyInput {
  create: [DisplayCreateInput!]
  connect: [DisplayWhereUniqueInput!]
}

input DisplayCreateOneInput {
  create: DisplayCreateInput
  connect: DisplayWhereUniqueInput
}

type DisplayEdge {
  node: Display!
  cursor: String!
}

enum DisplayOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  trailer_ASC
  trailer_DESC
  big_ASC
  big_DESC
  medium_ASC
  medium_DESC
  small_ASC
  small_DESC
  likeable_ASC
  likeable_DESC
}

type DisplayPreviousValues {
  id: ID!
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: MediaType
  type_not: MediaType
  type_in: [MediaType!]
  type_not_in: [MediaType!]
  trailer: String
  trailer_not: String
  trailer_in: [String!]
  trailer_not_in: [String!]
  trailer_lt: String
  trailer_lte: String
  trailer_gt: String
  trailer_gte: String
  trailer_contains: String
  trailer_not_contains: String
  trailer_starts_with: String
  trailer_not_starts_with: String
  trailer_ends_with: String
  trailer_not_ends_with: String
  big: String
  big_not: String
  big_in: [String!]
  big_not_in: [String!]
  big_lt: String
  big_lte: String
  big_gt: String
  big_gte: String
  big_contains: String
  big_not_contains: String
  big_starts_with: String
  big_not_starts_with: String
  big_ends_with: String
  big_not_ends_with: String
  medium: String
  medium_not: String
  medium_in: [String!]
  medium_not_in: [String!]
  medium_lt: String
  medium_lte: String
  medium_gt: String
  medium_gte: String
  medium_contains: String
  medium_not_contains: String
  medium_starts_with: String
  medium_not_starts_with: String
  medium_ends_with: String
  medium_not_ends_with: String
  small: String
  small_not: String
  small_in: [String!]
  small_not_in: [String!]
  small_lt: String
  small_lte: String
  small_gt: String
  small_gte: String
  small_contains: String
  small_not_contains: String
  small_starts_with: String
  small_not_starts_with: String
  small_ends_with: String
  small_not_ends_with: String
  likeable: Likeable
  likeable_not: Likeable
  likeable_in: [Likeable!]
  likeable_not_in: [Likeable!]
  AND: [DisplayScalarWhereInput!]
  OR: [DisplayScalarWhereInput!]
  NOT: [DisplayScalarWhereInput!]
}

type DisplaySubscriptionPayload {
  mutation: MutationType!
  node: Display
  updatedFields: [String!]
  previousValues: DisplayPreviousValues
}

input DisplaySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DisplayWhereInput
  AND: [DisplaySubscriptionWhereInput!]
  OR: [DisplaySubscriptionWhereInput!]
  NOT: [DisplaySubscriptionWhereInput!]
}

input DisplayUpdateDataInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateManyDataInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateManyInput {
  create: [DisplayCreateInput!]
  update: [DisplayUpdateWithWhereUniqueNestedInput!]
  upsert: [DisplayUpsertWithWhereUniqueNestedInput!]
  delete: [DisplayWhereUniqueInput!]
  connect: [DisplayWhereUniqueInput!]
  set: [DisplayWhereUniqueInput!]
  disconnect: [DisplayWhereUniqueInput!]
  deleteMany: [DisplayScalarWhereInput!]
  updateMany: [DisplayUpdateManyWithWhereNestedInput!]
}

input DisplayUpdateManyMutationInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateManyWithWhereNestedInput {
  where: DisplayScalarWhereInput!
  data: DisplayUpdateManyDataInput!
}

input DisplayUpdateOneInput {
  create: DisplayCreateInput
  update: DisplayUpdateDataInput
  upsert: DisplayUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DisplayWhereUniqueInput
}

input DisplayUpdateOneRequiredInput {
  create: DisplayCreateInput
  update: DisplayUpdateDataInput
  upsert: DisplayUpsertNestedInput
  connect: DisplayWhereUniqueInput
}

input DisplayUpdateWithWhereUniqueNestedInput {
  where: DisplayWhereUniqueInput!
  data: DisplayUpdateDataInput!
}

input DisplayUpsertNestedInput {
  update: DisplayUpdateDataInput!
  create: DisplayCreateInput!
}

input DisplayUpsertWithWhereUniqueNestedInput {
  where: DisplayWhereUniqueInput!
  update: DisplayUpdateDataInput!
  create: DisplayCreateInput!
}

input DisplayWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: MediaType
  type_not: MediaType
  type_in: [MediaType!]
  type_not_in: [MediaType!]
  trailer: String
  trailer_not: String
  trailer_in: [String!]
  trailer_not_in: [String!]
  trailer_lt: String
  trailer_lte: String
  trailer_gt: String
  trailer_gte: String
  trailer_contains: String
  trailer_not_contains: String
  trailer_starts_with: String
  trailer_not_starts_with: String
  trailer_ends_with: String
  trailer_not_ends_with: String
  big: String
  big_not: String
  big_in: [String!]
  big_not_in: [String!]
  big_lt: String
  big_lte: String
  big_gt: String
  big_gte: String
  big_contains: String
  big_not_contains: String
  big_starts_with: String
  big_not_starts_with: String
  big_ends_with: String
  big_not_ends_with: String
  medium: String
  medium_not: String
  medium_in: [String!]
  medium_not_in: [String!]
  medium_lt: String
  medium_lte: String
  medium_gt: String
  medium_gte: String
  medium_contains: String
  medium_not_contains: String
  medium_starts_with: String
  medium_not_starts_with: String
  medium_ends_with: String
  medium_not_ends_with: String
  small: String
  small_not: String
  small_in: [String!]
  small_not_in: [String!]
  small_lt: String
  small_lte: String
  small_gt: String
  small_gte: String
  small_contains: String
  small_not_contains: String
  small_starts_with: String
  small_not_starts_with: String
  small_ends_with: String
  small_not_ends_with: String
  likeable: Likeable
  likeable_not: Likeable
  likeable_in: [Likeable!]
  likeable_not_in: [Likeable!]
  AND: [DisplayWhereInput!]
  OR: [DisplayWhereInput!]
  NOT: [DisplayWhereInput!]
}

input DisplayWhereUniqueInput {
  id: ID
}

enum Likeable {
  LIKEABLE
  NOT_LIKEABLE
}

scalar Long

type Manga {
  id: ID!
  name: String!
  url: String!
  season: Season!
  progression(where: ProgressionWhereInput, orderBy: ProgressionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progression!]
}

type MangaConnection {
  pageInfo: PageInfo!
  edges: [MangaEdge]!
  aggregate: AggregateManga!
}

input MangaCreateInput {
  id: ID
  name: String!
  url: String!
  season: SeasonCreateOneWithoutMangasInput!
  progression: ProgressionCreateManyWithoutMangaInput
}

input MangaCreateManyWithoutSeasonInput {
  create: [MangaCreateWithoutSeasonInput!]
  connect: [MangaWhereUniqueInput!]
}

input MangaCreateOneWithoutProgressionInput {
  create: MangaCreateWithoutProgressionInput
  connect: MangaWhereUniqueInput
}

input MangaCreateWithoutProgressionInput {
  id: ID
  name: String!
  url: String!
  season: SeasonCreateOneWithoutMangasInput!
}

input MangaCreateWithoutSeasonInput {
  id: ID
  name: String!
  url: String!
  progression: ProgressionCreateManyWithoutMangaInput
}

type MangaEdge {
  node: Manga!
  cursor: String!
}

enum MangaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  url_ASC
  url_DESC
}

type MangaPreviousValues {
  id: ID!
  name: String!
  url: String!
}

input MangaScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [MangaScalarWhereInput!]
  OR: [MangaScalarWhereInput!]
  NOT: [MangaScalarWhereInput!]
}

type MangaSubscriptionPayload {
  mutation: MutationType!
  node: Manga
  updatedFields: [String!]
  previousValues: MangaPreviousValues
}

input MangaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MangaWhereInput
  AND: [MangaSubscriptionWhereInput!]
  OR: [MangaSubscriptionWhereInput!]
  NOT: [MangaSubscriptionWhereInput!]
}

input MangaUpdateInput {
  name: String
  url: String
  season: SeasonUpdateOneRequiredWithoutMangasInput
  progression: ProgressionUpdateManyWithoutMangaInput
}

input MangaUpdateManyDataInput {
  name: String
  url: String
}

input MangaUpdateManyMutationInput {
  name: String
  url: String
}

input MangaUpdateManyWithoutSeasonInput {
  create: [MangaCreateWithoutSeasonInput!]
  delete: [MangaWhereUniqueInput!]
  connect: [MangaWhereUniqueInput!]
  set: [MangaWhereUniqueInput!]
  disconnect: [MangaWhereUniqueInput!]
  update: [MangaUpdateWithWhereUniqueWithoutSeasonInput!]
  upsert: [MangaUpsertWithWhereUniqueWithoutSeasonInput!]
  deleteMany: [MangaScalarWhereInput!]
  updateMany: [MangaUpdateManyWithWhereNestedInput!]
}

input MangaUpdateManyWithWhereNestedInput {
  where: MangaScalarWhereInput!
  data: MangaUpdateManyDataInput!
}

input MangaUpdateOneWithoutProgressionInput {
  create: MangaCreateWithoutProgressionInput
  update: MangaUpdateWithoutProgressionDataInput
  upsert: MangaUpsertWithoutProgressionInput
  delete: Boolean
  disconnect: Boolean
  connect: MangaWhereUniqueInput
}

input MangaUpdateWithoutProgressionDataInput {
  name: String
  url: String
  season: SeasonUpdateOneRequiredWithoutMangasInput
}

input MangaUpdateWithoutSeasonDataInput {
  name: String
  url: String
  progression: ProgressionUpdateManyWithoutMangaInput
}

input MangaUpdateWithWhereUniqueWithoutSeasonInput {
  where: MangaWhereUniqueInput!
  data: MangaUpdateWithoutSeasonDataInput!
}

input MangaUpsertWithoutProgressionInput {
  update: MangaUpdateWithoutProgressionDataInput!
  create: MangaCreateWithoutProgressionInput!
}

input MangaUpsertWithWhereUniqueWithoutSeasonInput {
  where: MangaWhereUniqueInput!
  update: MangaUpdateWithoutSeasonDataInput!
  create: MangaCreateWithoutSeasonInput!
}

input MangaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  season: SeasonWhereInput
  progression_every: ProgressionWhereInput
  progression_some: ProgressionWhereInput
  progression_none: ProgressionWhereInput
  AND: [MangaWhereInput!]
  OR: [MangaWhereInput!]
  NOT: [MangaWhereInput!]
}

input MangaWhereUniqueInput {
  id: ID
  url: String
}

enum MediaType {
  SERIE
  MOVIE
  MANGA
  ANIME
}

type Mutation {
  createDisplay(data: DisplayCreateInput!): Display!
  updateDisplay(data: DisplayUpdateInput!, where: DisplayWhereUniqueInput!): Display
  updateManyDisplays(data: DisplayUpdateManyMutationInput!, where: DisplayWhereInput): BatchPayload!
  upsertDisplay(where: DisplayWhereUniqueInput!, create: DisplayCreateInput!, update: DisplayUpdateInput!): Display!
  deleteDisplay(where: DisplayWhereUniqueInput!): Display
  deleteManyDisplays(where: DisplayWhereInput): BatchPayload!
  createManga(data: MangaCreateInput!): Manga!
  updateManga(data: MangaUpdateInput!, where: MangaWhereUniqueInput!): Manga
  updateManyMangas(data: MangaUpdateManyMutationInput!, where: MangaWhereInput): BatchPayload!
  upsertManga(where: MangaWhereUniqueInput!, create: MangaCreateInput!, update: MangaUpdateInput!): Manga!
  deleteManga(where: MangaWhereUniqueInput!): Manga
  deleteManyMangas(where: MangaWhereInput): BatchPayload!
  createProgression(data: ProgressionCreateInput!): Progression!
  updateProgression(data: ProgressionUpdateInput!, where: ProgressionWhereUniqueInput!): Progression
  updateManyProgressions(data: ProgressionUpdateManyMutationInput!, where: ProgressionWhereInput): BatchPayload!
  upsertProgression(where: ProgressionWhereUniqueInput!, create: ProgressionCreateInput!, update: ProgressionUpdateInput!): Progression!
  deleteProgression(where: ProgressionWhereUniqueInput!): Progression
  deleteManyProgressions(where: ProgressionWhereInput): BatchPayload!
  createSeason(data: SeasonCreateInput!): Season!
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateManySeasons(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): BatchPayload!
  upsertSeason(where: SeasonWhereUniqueInput!, create: SeasonCreateInput!, update: SeasonUpdateInput!): Season!
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteManySeasons(where: SeasonWhereInput): BatchPayload!
  createSerie(data: SerieCreateInput!): Serie!
  updateSerie(data: SerieUpdateInput!, where: SerieWhereUniqueInput!): Serie
  updateManySeries(data: SerieUpdateManyMutationInput!, where: SerieWhereInput): BatchPayload!
  upsertSerie(where: SerieWhereUniqueInput!, create: SerieCreateInput!, update: SerieUpdateInput!): Serie!
  deleteSerie(where: SerieWhereUniqueInput!): Serie
  deleteManySeries(where: SerieWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVideo(data: VideoCreateInput!): Video!
  updateVideo(data: VideoUpdateInput!, where: VideoWhereUniqueInput!): Video
  updateManyVideos(data: VideoUpdateManyMutationInput!, where: VideoWhereInput): BatchPayload!
  upsertVideo(where: VideoWhereUniqueInput!, create: VideoCreateInput!, update: VideoUpdateInput!): Video!
  deleteVideo(where: VideoWhereUniqueInput!): Video
  deleteManyVideos(where: VideoWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Progression {
  id: ID!
  avancement: Float!
  video: Video
  user: User!
  manga: Manga
}

type ProgressionConnection {
  pageInfo: PageInfo!
  edges: [ProgressionEdge]!
  aggregate: AggregateProgression!
}

input ProgressionCreateInput {
  id: ID
  avancement: Float!
  video: VideoCreateOneWithoutProgressionInput
  user: UserCreateOneWithoutProgressionesInput!
  manga: MangaCreateOneWithoutProgressionInput
}

input ProgressionCreateManyWithoutMangaInput {
  create: [ProgressionCreateWithoutMangaInput!]
  connect: [ProgressionWhereUniqueInput!]
}

input ProgressionCreateManyWithoutUserInput {
  create: [ProgressionCreateWithoutUserInput!]
  connect: [ProgressionWhereUniqueInput!]
}

input ProgressionCreateManyWithoutVideoInput {
  create: [ProgressionCreateWithoutVideoInput!]
  connect: [ProgressionWhereUniqueInput!]
}

input ProgressionCreateWithoutMangaInput {
  id: ID
  avancement: Float!
  video: VideoCreateOneWithoutProgressionInput
  user: UserCreateOneWithoutProgressionesInput!
}

input ProgressionCreateWithoutUserInput {
  id: ID
  avancement: Float!
  video: VideoCreateOneWithoutProgressionInput
  manga: MangaCreateOneWithoutProgressionInput
}

input ProgressionCreateWithoutVideoInput {
  id: ID
  avancement: Float!
  user: UserCreateOneWithoutProgressionesInput!
  manga: MangaCreateOneWithoutProgressionInput
}

type ProgressionEdge {
  node: Progression!
  cursor: String!
}

enum ProgressionOrderByInput {
  id_ASC
  id_DESC
  avancement_ASC
  avancement_DESC
}

type ProgressionPreviousValues {
  id: ID!
  avancement: Float!
}

input ProgressionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  avancement: Float
  avancement_not: Float
  avancement_in: [Float!]
  avancement_not_in: [Float!]
  avancement_lt: Float
  avancement_lte: Float
  avancement_gt: Float
  avancement_gte: Float
  AND: [ProgressionScalarWhereInput!]
  OR: [ProgressionScalarWhereInput!]
  NOT: [ProgressionScalarWhereInput!]
}

type ProgressionSubscriptionPayload {
  mutation: MutationType!
  node: Progression
  updatedFields: [String!]
  previousValues: ProgressionPreviousValues
}

input ProgressionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProgressionWhereInput
  AND: [ProgressionSubscriptionWhereInput!]
  OR: [ProgressionSubscriptionWhereInput!]
  NOT: [ProgressionSubscriptionWhereInput!]
}

input ProgressionUpdateInput {
  avancement: Float
  video: VideoUpdateOneWithoutProgressionInput
  user: UserUpdateOneRequiredWithoutProgressionesInput
  manga: MangaUpdateOneWithoutProgressionInput
}

input ProgressionUpdateManyDataInput {
  avancement: Float
}

input ProgressionUpdateManyMutationInput {
  avancement: Float
}

input ProgressionUpdateManyWithoutMangaInput {
  create: [ProgressionCreateWithoutMangaInput!]
  delete: [ProgressionWhereUniqueInput!]
  connect: [ProgressionWhereUniqueInput!]
  set: [ProgressionWhereUniqueInput!]
  disconnect: [ProgressionWhereUniqueInput!]
  update: [ProgressionUpdateWithWhereUniqueWithoutMangaInput!]
  upsert: [ProgressionUpsertWithWhereUniqueWithoutMangaInput!]
  deleteMany: [ProgressionScalarWhereInput!]
  updateMany: [ProgressionUpdateManyWithWhereNestedInput!]
}

input ProgressionUpdateManyWithoutUserInput {
  create: [ProgressionCreateWithoutUserInput!]
  delete: [ProgressionWhereUniqueInput!]
  connect: [ProgressionWhereUniqueInput!]
  set: [ProgressionWhereUniqueInput!]
  disconnect: [ProgressionWhereUniqueInput!]
  update: [ProgressionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ProgressionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ProgressionScalarWhereInput!]
  updateMany: [ProgressionUpdateManyWithWhereNestedInput!]
}

input ProgressionUpdateManyWithoutVideoInput {
  create: [ProgressionCreateWithoutVideoInput!]
  delete: [ProgressionWhereUniqueInput!]
  connect: [ProgressionWhereUniqueInput!]
  set: [ProgressionWhereUniqueInput!]
  disconnect: [ProgressionWhereUniqueInput!]
  update: [ProgressionUpdateWithWhereUniqueWithoutVideoInput!]
  upsert: [ProgressionUpsertWithWhereUniqueWithoutVideoInput!]
  deleteMany: [ProgressionScalarWhereInput!]
  updateMany: [ProgressionUpdateManyWithWhereNestedInput!]
}

input ProgressionUpdateManyWithWhereNestedInput {
  where: ProgressionScalarWhereInput!
  data: ProgressionUpdateManyDataInput!
}

input ProgressionUpdateWithoutMangaDataInput {
  avancement: Float
  video: VideoUpdateOneWithoutProgressionInput
  user: UserUpdateOneRequiredWithoutProgressionesInput
}

input ProgressionUpdateWithoutUserDataInput {
  avancement: Float
  video: VideoUpdateOneWithoutProgressionInput
  manga: MangaUpdateOneWithoutProgressionInput
}

input ProgressionUpdateWithoutVideoDataInput {
  avancement: Float
  user: UserUpdateOneRequiredWithoutProgressionesInput
  manga: MangaUpdateOneWithoutProgressionInput
}

input ProgressionUpdateWithWhereUniqueWithoutMangaInput {
  where: ProgressionWhereUniqueInput!
  data: ProgressionUpdateWithoutMangaDataInput!
}

input ProgressionUpdateWithWhereUniqueWithoutUserInput {
  where: ProgressionWhereUniqueInput!
  data: ProgressionUpdateWithoutUserDataInput!
}

input ProgressionUpdateWithWhereUniqueWithoutVideoInput {
  where: ProgressionWhereUniqueInput!
  data: ProgressionUpdateWithoutVideoDataInput!
}

input ProgressionUpsertWithWhereUniqueWithoutMangaInput {
  where: ProgressionWhereUniqueInput!
  update: ProgressionUpdateWithoutMangaDataInput!
  create: ProgressionCreateWithoutMangaInput!
}

input ProgressionUpsertWithWhereUniqueWithoutUserInput {
  where: ProgressionWhereUniqueInput!
  update: ProgressionUpdateWithoutUserDataInput!
  create: ProgressionCreateWithoutUserInput!
}

input ProgressionUpsertWithWhereUniqueWithoutVideoInput {
  where: ProgressionWhereUniqueInput!
  update: ProgressionUpdateWithoutVideoDataInput!
  create: ProgressionCreateWithoutVideoInput!
}

input ProgressionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  avancement: Float
  avancement_not: Float
  avancement_in: [Float!]
  avancement_not_in: [Float!]
  avancement_lt: Float
  avancement_lte: Float
  avancement_gt: Float
  avancement_gte: Float
  video: VideoWhereInput
  user: UserWhereInput
  manga: MangaWhereInput
  AND: [ProgressionWhereInput!]
  OR: [ProgressionWhereInput!]
  NOT: [ProgressionWhereInput!]
}

input ProgressionWhereUniqueInput {
  id: ID
}

type Query {
  display(where: DisplayWhereUniqueInput!): Display
  displays(where: DisplayWhereInput, orderBy: DisplayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Display]!
  displaysConnection(where: DisplayWhereInput, orderBy: DisplayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DisplayConnection!
  manga(where: MangaWhereUniqueInput!): Manga
  mangas(where: MangaWhereInput, orderBy: MangaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Manga]!
  mangasConnection(where: MangaWhereInput, orderBy: MangaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MangaConnection!
  progression(where: ProgressionWhereUniqueInput!): Progression
  progressions(where: ProgressionWhereInput, orderBy: ProgressionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progression]!
  progressionsConnection(where: ProgressionWhereInput, orderBy: ProgressionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProgressionConnection!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Season]!
  seasonsConnection(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeasonConnection!
  serie(where: SerieWhereUniqueInput!): Serie
  series(where: SerieWhereInput, orderBy: SerieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Serie]!
  seriesConnection(where: SerieWhereInput, orderBy: SerieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SerieConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  video(where: VideoWhereUniqueInput!): Video
  videos(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Video]!
  videosConnection(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VideoConnection!
  node(id: ID!): Node
}

type Season {
  id: ID!
  name: String
  description: String
  episodes(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Video!]
  mangas(where: MangaWhereInput, orderBy: MangaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Manga!]
  url: String
  chapterCount: Int
}

type SeasonConnection {
  pageInfo: PageInfo!
  edges: [SeasonEdge]!
  aggregate: AggregateSeason!
}

input SeasonCreateInput {
  id: ID
  name: String
  description: String
  episodes: VideoCreateManyWithoutSeasonInput
  mangas: MangaCreateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

input SeasonCreateManyInput {
  create: [SeasonCreateInput!]
  connect: [SeasonWhereUniqueInput!]
}

input SeasonCreateOneWithoutEpisodesInput {
  create: SeasonCreateWithoutEpisodesInput
  connect: SeasonWhereUniqueInput
}

input SeasonCreateOneWithoutMangasInput {
  create: SeasonCreateWithoutMangasInput
  connect: SeasonWhereUniqueInput
}

input SeasonCreateWithoutEpisodesInput {
  id: ID
  name: String
  description: String
  mangas: MangaCreateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

input SeasonCreateWithoutMangasInput {
  id: ID
  name: String
  description: String
  episodes: VideoCreateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

type SeasonEdge {
  node: Season!
  cursor: String!
}

enum SeasonOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  url_ASC
  url_DESC
  chapterCount_ASC
  chapterCount_DESC
}

type SeasonPreviousValues {
  id: ID!
  name: String
  description: String
  url: String
  chapterCount: Int
}

input SeasonScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  chapterCount: Int
  chapterCount_not: Int
  chapterCount_in: [Int!]
  chapterCount_not_in: [Int!]
  chapterCount_lt: Int
  chapterCount_lte: Int
  chapterCount_gt: Int
  chapterCount_gte: Int
  AND: [SeasonScalarWhereInput!]
  OR: [SeasonScalarWhereInput!]
  NOT: [SeasonScalarWhereInput!]
}

type SeasonSubscriptionPayload {
  mutation: MutationType!
  node: Season
  updatedFields: [String!]
  previousValues: SeasonPreviousValues
}

input SeasonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeasonWhereInput
  AND: [SeasonSubscriptionWhereInput!]
  OR: [SeasonSubscriptionWhereInput!]
  NOT: [SeasonSubscriptionWhereInput!]
}

input SeasonUpdateDataInput {
  name: String
  description: String
  episodes: VideoUpdateManyWithoutSeasonInput
  mangas: MangaUpdateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

input SeasonUpdateInput {
  name: String
  description: String
  episodes: VideoUpdateManyWithoutSeasonInput
  mangas: MangaUpdateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

input SeasonUpdateManyDataInput {
  name: String
  description: String
  url: String
  chapterCount: Int
}

input SeasonUpdateManyInput {
  create: [SeasonCreateInput!]
  update: [SeasonUpdateWithWhereUniqueNestedInput!]
  upsert: [SeasonUpsertWithWhereUniqueNestedInput!]
  delete: [SeasonWhereUniqueInput!]
  connect: [SeasonWhereUniqueInput!]
  set: [SeasonWhereUniqueInput!]
  disconnect: [SeasonWhereUniqueInput!]
  deleteMany: [SeasonScalarWhereInput!]
  updateMany: [SeasonUpdateManyWithWhereNestedInput!]
}

input SeasonUpdateManyMutationInput {
  name: String
  description: String
  url: String
  chapterCount: Int
}

input SeasonUpdateManyWithWhereNestedInput {
  where: SeasonScalarWhereInput!
  data: SeasonUpdateManyDataInput!
}

input SeasonUpdateOneRequiredWithoutMangasInput {
  create: SeasonCreateWithoutMangasInput
  update: SeasonUpdateWithoutMangasDataInput
  upsert: SeasonUpsertWithoutMangasInput
  connect: SeasonWhereUniqueInput
}

input SeasonUpdateOneWithoutEpisodesInput {
  create: SeasonCreateWithoutEpisodesInput
  update: SeasonUpdateWithoutEpisodesDataInput
  upsert: SeasonUpsertWithoutEpisodesInput
  delete: Boolean
  disconnect: Boolean
  connect: SeasonWhereUniqueInput
}

input SeasonUpdateWithoutEpisodesDataInput {
  name: String
  description: String
  mangas: MangaUpdateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

input SeasonUpdateWithoutMangasDataInput {
  name: String
  description: String
  episodes: VideoUpdateManyWithoutSeasonInput
  url: String
  chapterCount: Int
}

input SeasonUpdateWithWhereUniqueNestedInput {
  where: SeasonWhereUniqueInput!
  data: SeasonUpdateDataInput!
}

input SeasonUpsertWithoutEpisodesInput {
  update: SeasonUpdateWithoutEpisodesDataInput!
  create: SeasonCreateWithoutEpisodesInput!
}

input SeasonUpsertWithoutMangasInput {
  update: SeasonUpdateWithoutMangasDataInput!
  create: SeasonCreateWithoutMangasInput!
}

input SeasonUpsertWithWhereUniqueNestedInput {
  where: SeasonWhereUniqueInput!
  update: SeasonUpdateDataInput!
  create: SeasonCreateInput!
}

input SeasonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  episodes_every: VideoWhereInput
  episodes_some: VideoWhereInput
  episodes_none: VideoWhereInput
  mangas_every: MangaWhereInput
  mangas_some: MangaWhereInput
  mangas_none: MangaWhereInput
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  chapterCount: Int
  chapterCount_not: Int
  chapterCount_in: [Int!]
  chapterCount_not_in: [Int!]
  chapterCount_lt: Int
  chapterCount_lte: Int
  chapterCount_gt: Int
  chapterCount_gte: Int
  AND: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
}

input SeasonWhereUniqueInput {
  id: ID
  url: String
}

type Serie {
  id: ID!
  name: String!
  description: String
  display: Display
  seasons(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Season!]
  color: String
}

type SerieConnection {
  pageInfo: PageInfo!
  edges: [SerieEdge]!
  aggregate: AggregateSerie!
}

input SerieCreateInput {
  id: ID
  name: String!
  description: String
  display: DisplayCreateOneInput
  seasons: SeasonCreateManyInput
  color: String
}

type SerieEdge {
  node: Serie!
  cursor: String!
}

enum SerieOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  color_ASC
  color_DESC
}

type SeriePreviousValues {
  id: ID!
  name: String!
  description: String
  color: String
}

type SerieSubscriptionPayload {
  mutation: MutationType!
  node: Serie
  updatedFields: [String!]
  previousValues: SeriePreviousValues
}

input SerieSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SerieWhereInput
  AND: [SerieSubscriptionWhereInput!]
  OR: [SerieSubscriptionWhereInput!]
  NOT: [SerieSubscriptionWhereInput!]
}

input SerieUpdateInput {
  name: String
  description: String
  display: DisplayUpdateOneInput
  seasons: SeasonUpdateManyInput
  color: String
}

input SerieUpdateManyMutationInput {
  name: String
  description: String
  color: String
}

input SerieWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  display: DisplayWhereInput
  seasons_every: SeasonWhereInput
  seasons_some: SeasonWhereInput
  seasons_none: SeasonWhereInput
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  AND: [SerieWhereInput!]
  OR: [SerieWhereInput!]
  NOT: [SerieWhereInput!]
}

input SerieWhereUniqueInput {
  id: ID
}

enum Sexe {
  MALE
  FEMALE
  OTHER
}

type Subscription {
  display(where: DisplaySubscriptionWhereInput): DisplaySubscriptionPayload
  manga(where: MangaSubscriptionWhereInput): MangaSubscriptionPayload
  progression(where: ProgressionSubscriptionWhereInput): ProgressionSubscriptionPayload
  season(where: SeasonSubscriptionWhereInput): SeasonSubscriptionPayload
  serie(where: SerieSubscriptionWhereInput): SerieSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  video(where: VideoSubscriptionWhereInput): VideoSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences(where: DisplayWhereInput, orderBy: DisplayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Display!]
  description: String
  sexe: Sexe
  Progressiones(where: ProgressionWhereInput, orderBy: ProgressionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progression!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayCreateManyInput
  description: String
  sexe: Sexe
  Progressiones: ProgressionCreateManyWithoutUserInput
}

input UserCreateOneWithoutProgressionesInput {
  create: UserCreateWithoutProgressionesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutProgressionesInput {
  id: ID
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayCreateManyInput
  description: String
  sexe: Sexe
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  birthday_ASC
  birthday_DESC
  description_ASC
  description_DESC
  sexe_ASC
  sexe_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  description: String
  sexe: Sexe
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  username: String
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayUpdateManyInput
  description: String
  sexe: Sexe
  Progressiones: ProgressionUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  description: String
  sexe: Sexe
}

input UserUpdateOneRequiredWithoutProgressionesInput {
  create: UserCreateWithoutProgressionesInput
  update: UserUpdateWithoutProgressionesDataInput
  upsert: UserUpsertWithoutProgressionesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutProgressionesDataInput {
  username: String
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayUpdateManyInput
  description: String
  sexe: Sexe
}

input UserUpsertWithoutProgressionesInput {
  update: UserUpdateWithoutProgressionesDataInput!
  create: UserCreateWithoutProgressionesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  birthday: DateTime
  birthday_not: DateTime
  birthday_in: [DateTime!]
  birthday_not_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  preferences_every: DisplayWhereInput
  preferences_some: DisplayWhereInput
  preferences_none: DisplayWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  sexe: Sexe
  sexe_not: Sexe
  sexe_in: [Sexe!]
  sexe_not_in: [Sexe!]
  Progressiones_every: ProgressionWhereInput
  Progressiones_some: ProgressionWhereInput
  Progressiones_none: ProgressionWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
  email: String
}

type Video {
  id: ID!
  name: String!
  url: String!
  display: Display!
  season: Season
  Progression(where: ProgressionWhereInput, orderBy: ProgressionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progression!]
}

type VideoConnection {
  pageInfo: PageInfo!
  edges: [VideoEdge]!
  aggregate: AggregateVideo!
}

input VideoCreateInput {
  id: ID
  name: String!
  url: String!
  display: DisplayCreateOneInput!
  season: SeasonCreateOneWithoutEpisodesInput
  Progression: ProgressionCreateManyWithoutVideoInput
}

input VideoCreateManyWithoutSeasonInput {
  create: [VideoCreateWithoutSeasonInput!]
  connect: [VideoWhereUniqueInput!]
}

input VideoCreateOneWithoutProgressionInput {
  create: VideoCreateWithoutProgressionInput
  connect: VideoWhereUniqueInput
}

input VideoCreateWithoutProgressionInput {
  id: ID
  name: String!
  url: String!
  display: DisplayCreateOneInput!
  season: SeasonCreateOneWithoutEpisodesInput
}

input VideoCreateWithoutSeasonInput {
  id: ID
  name: String!
  url: String!
  display: DisplayCreateOneInput!
  Progression: ProgressionCreateManyWithoutVideoInput
}

type VideoEdge {
  node: Video!
  cursor: String!
}

enum VideoOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  url_ASC
  url_DESC
}

type VideoPreviousValues {
  id: ID!
  name: String!
  url: String!
}

input VideoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [VideoScalarWhereInput!]
  OR: [VideoScalarWhereInput!]
  NOT: [VideoScalarWhereInput!]
}

type VideoSubscriptionPayload {
  mutation: MutationType!
  node: Video
  updatedFields: [String!]
  previousValues: VideoPreviousValues
}

input VideoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VideoWhereInput
  AND: [VideoSubscriptionWhereInput!]
  OR: [VideoSubscriptionWhereInput!]
  NOT: [VideoSubscriptionWhereInput!]
}

input VideoUpdateInput {
  name: String
  url: String
  display: DisplayUpdateOneRequiredInput
  season: SeasonUpdateOneWithoutEpisodesInput
  Progression: ProgressionUpdateManyWithoutVideoInput
}

input VideoUpdateManyDataInput {
  name: String
  url: String
}

input VideoUpdateManyMutationInput {
  name: String
  url: String
}

input VideoUpdateManyWithoutSeasonInput {
  create: [VideoCreateWithoutSeasonInput!]
  delete: [VideoWhereUniqueInput!]
  connect: [VideoWhereUniqueInput!]
  set: [VideoWhereUniqueInput!]
  disconnect: [VideoWhereUniqueInput!]
  update: [VideoUpdateWithWhereUniqueWithoutSeasonInput!]
  upsert: [VideoUpsertWithWhereUniqueWithoutSeasonInput!]
  deleteMany: [VideoScalarWhereInput!]
  updateMany: [VideoUpdateManyWithWhereNestedInput!]
}

input VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput!
  data: VideoUpdateManyDataInput!
}

input VideoUpdateOneWithoutProgressionInput {
  create: VideoCreateWithoutProgressionInput
  update: VideoUpdateWithoutProgressionDataInput
  upsert: VideoUpsertWithoutProgressionInput
  delete: Boolean
  disconnect: Boolean
  connect: VideoWhereUniqueInput
}

input VideoUpdateWithoutProgressionDataInput {
  name: String
  url: String
  display: DisplayUpdateOneRequiredInput
  season: SeasonUpdateOneWithoutEpisodesInput
}

input VideoUpdateWithoutSeasonDataInput {
  name: String
  url: String
  display: DisplayUpdateOneRequiredInput
  Progression: ProgressionUpdateManyWithoutVideoInput
}

input VideoUpdateWithWhereUniqueWithoutSeasonInput {
  where: VideoWhereUniqueInput!
  data: VideoUpdateWithoutSeasonDataInput!
}

input VideoUpsertWithoutProgressionInput {
  update: VideoUpdateWithoutProgressionDataInput!
  create: VideoCreateWithoutProgressionInput!
}

input VideoUpsertWithWhereUniqueWithoutSeasonInput {
  where: VideoWhereUniqueInput!
  update: VideoUpdateWithoutSeasonDataInput!
  create: VideoCreateWithoutSeasonInput!
}

input VideoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  display: DisplayWhereInput
  season: SeasonWhereInput
  Progression_every: ProgressionWhereInput
  Progression_some: ProgressionWhereInput
  Progression_none: ProgressionWhereInput
  AND: [VideoWhereInput!]
  OR: [VideoWhereInput!]
  NOT: [VideoWhereInput!]
}

input VideoWhereUniqueInput {
  id: ID
}
`